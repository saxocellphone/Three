<!DOCTYPE html>
<html>
	<head>
		<title>A solids of revolution graphing calculator</title>
		<link rel="shortcut icon" href="https://lh6.googleusercontent.com/-eJP7CsCRims/AAAAAAAAAAI/AAAAAAAAAOE/9fdQHCWUWQs/s32-c-k-no/photo.jpg"/>
		<link rel="stylesheet" type="text/css" href="css/style.css">
		<link rel="stylesheet" type="text/css" href="css/sweet-alert.css">
		<meta charset="UTF-8">
	</head>

	<body>
		<a>Rotate y=</a>
		<input id="function1" class="functionInput" type="text" autofocus="autofocus" placeholder="function 1" name="function">
		<a> and y=</a>
		<input id="function2" class="functionInput" type="text" placeholder="function 2" name="function">
		<a> bounded by x=</a>
		<input id="bound1" class="boundInput" type="text" placeholder="bound 1" name="bounds">
		<a> and x=</a>
		<input id="bound2" class="boundInput" type="text" placeholder="bound 2" name="bounds">
		<a> around y=</a>
		<input id="rotation" class="rotationInput" type="text" onchange="submit()" placeholder="axis of rotation" name="rotation">
		<button type="button" onclick="submit()">Rotate!</button>
		<!-- <input id="rotate" type="range" onchange="rotate()" min="0" max="360" value="360" step="30"/> -->

		<a>Make sure to type the function in a <a href="http://www.w3schools.com/jsref/jsref_obj_math.asp" target="_blank">programming format</a>.  For example, 2x+3 is <b>2*x+3</b>, and sin(2x) is <b>Math.sin(2*x)</b>.</a>
		<br>
		<select id="quality" onchange="submit()">
			<option value="0.5">Select Quality
			<option value="1">Low
			<option value="0.5">Medium
			<option value="0.25">High
			<option value="0.1">Ultra
		</select>
		<br>
		<a>This calculator is a <a href="https://github.com/saxocellphone/Three" target="_blank"><b>work in progress</b></a> and things may not work as expected!  In addition, take notice that this calculator is currently very memory intensive.</a>

		<noscript>
			<div id="javascript-error-message" style="font-family: monospace; font-size: 13px; font-weight: normal; text-align: center; background: none repeat scroll 0% 0% rgb(255, 255, 255); color: rgb(0, 0, 0); padding: 1.5em; width: 400px; margin: 5em auto 0px;">
				<a>Your browser seems to have <a href="http://en.wikipedia.org/wiki/JavaScript">Javascript</a> turned off.</a>
				<br>
				<a>Find out how to enable it <a href="http://www.enable-javascript.com/" target="_blank">here</a>.</a>
			</div>
		</noscript>

		<script src="js/sweet-alert.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CanvasInput.js"></script>
		<script src="js/ThreeCSG.js"></script>
		<script src="js/Detector.js"></script>
		<script>
			"use strict";
			var camera, controls, scene, renderer;
			var size=28;
			var graphArray=[];

			init();

			function init(){
				if(!Detector.webgl){  //No WebGL D:
					Detector.addGetWebGLMessage();
					return;
				}

				scene=new THREE.Scene();

				camera=new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
				camera.position.y=75;
				camera.position.z=5;

				renderer=new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				controls=new THREE.TrackballControls(camera, renderer.domElement);
				controls.addEventListener('change', render);

				addAxis();
				addLights();
				animate();
				render();
			}

			function Graph(given, bound1, bound2, axisOfRotation, quality, graphID){
				this.given=given;
				this.group=new THREE.Object3D();
				this.bound1=bound1;
				this.bound2=bound2;
				this.axisOfRotation=axisOfRotation;
				this.quality=quality;
				this.graphID=graphID;
			}

			Graph.prototype.draw=function(){
				var x=-size;
				var points=[];
				var counter=x;  //I'll change this later, just using a counter variable for now
				var step=0.01;
				var func;  //Find a better name for this maybe?
				for(var i=-size; i<=size; i+=step){
					if(this.given!==null){
						func=-(eval(this.given));  //Somehow the plane is upside-down: the positive y-cordinate is negative
					}

					points[counter+size]=new THREE.Vector3(x.toFixed(2), 0, func);
					x+=step;
					counter++;
				}

				var geometry=new THREE.Geometry();
				geometry.verticesNeedUpdate=true;

				var spline=new THREE.SplineCurve3(points);
				var splinePoints=spline.getPoints(points.length-1);

				for(i=0; i<splinePoints.length; i++){
					if(Math.abs((spline.points[i]).z)<=size){
						geometry.vertices.push(spline.points[i]);
					}
				}

				var graph=new THREE.Line(geometry, new THREE.LineBasicMaterial());
				graph.name="graph";
				scene.add(graph);
				render();
			};

			Graph.prototype.getY=function(x){
				return eval(this.given);
			};

			Graph.prototype.drawShape=function(){
				this.group.name="solid";
				var boundY1=this.getY(this.bound1);
				var boundY2=this.getY(this.bound2);
				var graph1ComparingPoint1=graphArray[0].getY(this.bound1+0.5);  //FIXME: Don't assume that there's always two functions
				var graph2ComparingPoint1=graphArray[1].getY(this.bound1+0.5);
				var graph1ComparingPoint2=graphArray[0].getY(this.bound2-0.5);
				var graph2ComparingPoint2=graphArray[1].getY(this.bound2-0.5);

				if(this.bound1===this.bound2){
					sweetAlert("Oh noes!", "We're still working on creating the solid when the bounds are equal.\nSorry about that :(", "warning");
					clearGraph();
					return;
				}

				if(boundY1>boundY2){  //Switch the bounds around so that the for loop works
					var temp=this.bound2;
					this.bound2=this.bound1;
					this.bound1=temp;

					temp=boundY2;
					boundY2=boundY1;
					boundY1=temp;
				}

				//I know this is a lot of if statements, I did it to ensure there wouldn't be any bugs. There are probably ways you can have an abridged version, but this will do for now.
				if(this.axisOfRotation){
					console.log("Axis of rotation is not 0");
					if(boundY2-boundY1){
						console.log("	boundY2-boundY1 is not 0");
						if(this.axisOfRotation>=boundY2 && this.axisOfRotation>=graphArray[1].getY(this.bound2)){
							console.log("		Axis of rotation is greater than or equal to boundY2");
							if(boundY1>=0 && boundY2>=0){
								console.log("			Both boundY1 and boundY2 are greater than or equal to 0");
								if(graph2ComparingPoint1>graph1ComparingPoint1 && graph2ComparingPoint2>graph1ComparingPoint2){
									console.log("					Graph2 is higher than graph1");
									this.addBSP("this.axisOfRotation-graphArray[1].getY(i)", "this.axisOfRotation-graphArray[1].getY(i+0.5)", "this.axisOfRotation-this.getY(i)", "this.axisOfRotation-this.getY(i+0.5)");
								} else {
									console.log("					Graph2 is lower than or equal to graph1");
									this.addBSP("this.axisOfRotation-this.getY(i)", "this.axisOfRotation-this.getY(i+0.5)", "this.axisOfRotation-graphArray[1].getY(i)", "this.axisOfRotation-graphArray[1].getY(i+0.5)");
								}
							} else {
								console.log("			One of the bounds is less than 0");
								if(graph2ComparingPoint1>graph1ComparingPoint1 && graph2ComparingPoint2>graph1ComparingPoint2){
									console.log("					Graph2 is higher than graph1");
									this.addBSP("this.axisOfRotation+Math.abs(graphArray[1].getY(i))", "this.axisOfRotation+Math.abs(graphArray[1].getY(i+0.5))", "this.axisOfRotation-this.getY(i)", "this.axisOfRotation-this.getY(i+0.5)");
								} else {
									console.log("					Graph2 is lower than or equal to graph1");
									this.addBSP("this.axisOfRotation-this.getY(i)", "this.axisOfRotation-this.getY(i+0.5)", "this.axisOfRotation-graphArray[1].getY(i)", "this.axisOfRotation-graphArray[1].getY(i+0.5)");
								}
							}
						} else if(this.axisOfRotation<=boundY1 && this.axisOfRotation<=graphArray[1].getY(this.bound1)){
							console.log("		Axis of rotation is less than or equal to boundY1");
							if(boundY1>=0 && boundY2>=0){
								console.log("			Both boundY1 and boundY2 are greater than or equal to 0");
								if(graph2ComparingPoint1>graph1ComparingPoint1 && graph2ComparingPoint2>graph1ComparingPoint2){
									console.log("					Graph2 is higher than graph1");
									this.addBSP("Math.abs(this.axisOfRotation)+this.getY(i)", "Math.abs(this.axisOfRotation)+this.getY(i+0.5)", "Math.abs(this.axisOfRotation)+graphArray[1].getY(i)", "Math.abs(this.axisOfRotation)+graphArray[1].getY(i+0.5)");
								} else {
									console.log("					Graph2 is lower than or equal to graph1");
									this.addBSP("Math.abs(this.axisOfRotation)+graphArray[1].getY(i)", "Math.abs(this.axisOfRotation)+graphArray[1].getY(i+0.5)", "Math.abs(this.axisOfRotation)+this.getY(i)", "Math.abs(this.axisOfRotation)+this.getY(i+0.5)");
								}
							} else {
								console.log("			One of the bounds is less than 0");
								if(graph2ComparingPoint1>graph1ComparingPoint1 && graph2ComparingPoint2>graph1ComparingPoint2){
									console.log("					Graph2 is higher than graph1");
									this.addBSP("Math.abs(this.axisOfRotation-this.getY(i))", "Math.abs(this.axisOfRotation-this.getY(i+0.5))", "Math.abs(this.axisOfRotation-graphArray[1].getY(i))", "Math.abs(this.axisOfRotation-graphArray[1].getY(i+0.5))");
								} else {
									console.log("					Graph2 is lower than or equal to graph1");
									this.addBSP("Math.abs(this.axisOfRotation-graphArray[1].getY(i))", "Math.abs(this.axisOfRotation-graphArray[1].getY(i+0.5))", "Math.abs(this.axisOfRotation-this.getY(i))", "Math.abs(this.axisOfRotation-this.getY(i+0.5))");
								}
							}
						} else {
							sweetAlert("Oh noes!", "Axis of rotation cannot be between the bounds", "warning");
							clearGraph();
							return;
						}
					} else if(boundY1===boundY2){
						//Not complete yet (this is just for cylinders)
						console.log("		BoundY1 is equal to boundY2 and bound1 does not equal bound2");
						if(this.axisOfRotation>boundY1){
							console.log("			Axis of rotation is greater than boundY1");
							this.addBSP("Math.abs(this.axisOfRotation-this.getY(i))", "Math.abs(this.axisOfRotation-this.getY(i+0.5))", "Math.abs(this.axisOfRotation)", "Math.abs(this.axisOfRotation)");
						} else if(this.axisOfRotation<boundY1){
							console.log("			Axis of rotation is less than boundY1");
							this.addBSP("Math.abs(this.axisOfRotation)", "Math.abs(this.axisOfRotation)", "Math.abs(this.axisOfRotation)+this.getY(i)", "Math.abs(this.axisOfRotation)+this.getY(i+0.5)");
						} else if(this.axisOfRotation===boundY1){
							console.log("			Axis of rotation is equal to boundY1");
							this.addSolidWithoutHoles("Math.abs(this.getY(i))", "Math.abs(this.getY(i+this.quality))");
						}
					}
				} else {
					console.log("Axis of rotation is 0");
					this.addSolidWithoutHoles("Math.abs(this.getY(i))", "Math.abs(this.getY(i+this.quality))");
				}
				scene.add(this.group);
				render();
			};

			Graph.prototype.addBSP=function(innerCylinderSmallRadius, innerCylinderLargeRadius, outerCylinderSmallRadius, outerCylinderLargeRadius){
				for(var i=this.bound1; i<this.bound2; i+=0.5){
					if(this.getY(i)<=size){
						if(!eval(innerCylinderSmallRadius) || !eval(innerCylinderLargeRadius)){  //Hacky bugfix woo
							innerCylinderSmallRadius=innerCylinderSmallRadius + "+0.01";
							innerCylinderLargeRadius=innerCylinderLargeRadius + "+0.01";
						}

						var smallCylinder, largeCylinder;
						if(i===this.bound1)
						{
							smallCylinder=new THREE.CylinderGeometry(eval(innerCylinderSmallRadius), eval(innerCylinderLargeRadius), 0.5, 50, 1, false, true);
						}
						else
						{
							smallCylinder=new THREE.CylinderGeometry(eval(innerCylinderSmallRadius), eval(innerCylinderLargeRadius), 0.5, 50, 1, true, true);
						}
						smallCylinder.applyMatrix(new THREE.Matrix4().makeTranslation(0, -(i+0.5/2), -this.axisOfRotation));

						if(i+0.5>=this.bound2)
						{
							largeCylinder=new THREE.CylinderGeometry(eval(outerCylinderSmallRadius), eval(outerCylinderLargeRadius), 0.5, 360, 1, true, false);
						}
						else
						{
							largeCylinder=new THREE.CylinderGeometry(eval(outerCylinderSmallRadius), eval(outerCylinderLargeRadius), 0.5, 360, 1, true, true);
						}
						largeCylinder.applyMatrix(new THREE.Matrix4().makeTranslation(0, -(i+0.5/2), -this.axisOfRotation));

						var hollowCylinder=new ThreeBSP(largeCylinder).subtract(new ThreeBSP(smallCylinder)).toMesh(new THREE.MeshPhongMaterial({color: 0xffff00, transparent: true, opacity: 0.5}));
						hollowCylinder.rotation.set(0, 0, Math.PI/2);
						this.group.add(hollowCylinder);
					}
				}
			};

			Graph.prototype.addSolidWithoutHoles=function(leftRadius, rightRadius){
				for(var i=this.bound1; i<this.bound2; i+=this.quality){
					if(this.getY(i)<=size){
						var geometry;
						if(i===this.bound1)
						{
							geometry=new THREE.CylinderGeometry(eval(leftRadius), eval(rightRadius), this.quality, 100, 1, false, true);
						}
						else if(i+this.quality>=this.bound2)
						{
							geometry=new THREE.CylinderGeometry(eval(leftRadius), eval(rightRadius), this.quality, 100, 1, true, false);
						}
						else
						{
							geometry=new THREE.CylinderGeometry(eval(leftRadius), eval(rightRadius), this.quality, 100, 1, true, true);
						}
						geometry.verticesNeedUpdate=true;
						geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -(i+this.quality/2), -this.axisOfRotation));

						var material=new THREE.MeshPhongMaterial({color: 0xffff00, transparent: true, opacity: 0.5});
						var plane=new THREE.Mesh(geometry, material);
						plane.material.color.setHex(0xffff00);

						plane.rotation.set(0, 0, Math.PI/2);
						this.group.add(plane);
					}
				}
			};

			function clearGraph(){
				for(var i=scene.children.length; i>=0; i--){
					if(scene.children[i]!==undefined){
						if(scene.children[i].name=="graph" || scene.children[i].name=="solid"){
							scene.remove(scene.children[i]);
						}
					}
				}
				render();
			}

			function submit(){
				clearGraph();

				//TODO: Being lazy for now, I'll change this later. Using eval()
				var function1=document.getElementById("function1").value.replace(/ /g,'');  //TODO: Check if this is valid
				var quality=document.getElementById("quality").value;
				var bound1=document.getElementById("bound1").value.replace(/ /g, '');
				var bound2=document.getElementById("bound2").value.replace(/ /g, '');
				var axisOfRotation=document.getElementById("rotation").value.replace(/ /g, '');

				if(isNaN(bound1) || isNaN(bound2) || isNaN(axisOfRotation))  //Make sure the values are valid
				{
					var type=(isNaN(bound1) ? "first bound" : isNaN(bound2) ? "second bound" : "axis of rotation");
					sweetAlert("Invalid " + type, "Please enter a valid number for the " + type, "warning");
					return;
				}

				var graph1=new Graph(function1, Number(bound1), Number(bound2), Number(axisOfRotation), Number(quality), 0);
				graphArray[graph1.graphID]=graph1;
				graph1.draw();

				var function2=document.getElementById("function2").value.replace(/ /g, '');
				var graph2;
				if(function2)
				{
					graph2=new Graph(function2, Number(bound1), Number(bound2), Number(axisOfRotation), Number(quality), 1);
					graph2.draw();
				}
				else  //Create a fake graph because drawShape() assumes that there's always going to be two functions
				{
					graph2=new Graph(0, Number(bound1), Number(bound2), Number(axisOfRotation), Number(quality), 1);
				}
				graphArray[graph2.graphID]=graph2;

				if(bound1 && bound2 && axisOfRotation)  //Only create the solid if we have both of the bounds and the axis of rotation
				{
					graph1.drawShape();
					return;
				}
				else if(!bound1 && !bound2 && !axisOfRotation)  //If everything was left blank we'll just draw the function and that's it
				{
					return;
				}
				else  //Otherwise, warn the user
				{
					var type=(!bound1 ? "first bound" : !bound2 ? "second bound" : "axis of rotation");
					sweetAlert("Missing " + type, "Please specify the " + type, "warning");
					return;
				}
			}

			function animate(){
				requestAnimationFrame(animate);
				controls.update();
			}

			function render(){
				renderer.render(scene, camera);
			}

			function addLights(){
				var hemiLight=new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
				hemiLight.color.setHSL(0.6, 1, 0.6);
				hemiLight.groundColor.setHSL(0.095, 1, 0.75);
				hemiLight.position.set(0, 500, 0);
				scene.add(hemiLight);

				var light1=new THREE.PointLight(0xffff00, 1, 5000);
				light1.position.set(0, 100, 90);
				scene.add(light1);
			}

			function addAxis(){
				var geometry=new THREE.Geometry();
				geometry.verticesNeedUpdate=true;

				var axes=new THREE.Geometry();
				axes.verticesNeedUpdate=true;

				for(var i=-size; i<=size; i+=1){
					if(i){
						geometry.vertices.push(new THREE.Vector3(-size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, -size));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, size));
					} else {
						axes.vertices.push(new THREE.Vector3(-size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(i, -0.04, -size));
						axes.vertices.push(new THREE.Vector3(i, -0.04, size));
					}
				}

				var material=new THREE.LineBasicMaterial({color: "green"});
				var axismaterial=new THREE.LineBasicMaterial({color: "red"});
				var line=new THREE.Line(geometry, material, THREE.LinePieces);
				var lineaxes=new THREE.Line(axes, axismaterial, THREE.LinePieces);

				scene.add(line);
				scene.add(lineaxes);
			}
		</script>
	</body>
</html>