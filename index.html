<!DOCTYPE html>
<html>
	<head>
		<title>A solids of revolution graphing calculator</title>
		<link rel="shortcut icon" href="https://lh6.googleusercontent.com/-eJP7CsCRims/AAAAAAAAAAI/AAAAAAAAAOE/9fdQHCWUWQs/s32-c-k-no/photo.jpg"/>
		<link rel="stylesheet" type="text/css" href="css/style.css">
		<meta charset="UTF-8">
	</head>

	<body>
		<a>Rotate y=</a>
		<input type="text" name="function" placeholder="function" class="functionInput" id="function">
		<a>Second Function</a>
		<input type="text" name="function" placeholder="function2" class="functionInput" id="function2">

		<a> bounded by x=</a>
		<input type="text" name="bounds" placeholder="bound 1" class="functionInput" id="bound1">
		<a> and x=</a>
		<input type="text" name="bounds" placeholder="bound 2" class="functionInput" id="bound2">
		<a> around y=</a>
		<input type="text" name="rotation" placeholder="axis of rotation" class="functionInput" id="rotation">
		<button type="button" onclick="submit()">Rotate!</button>
		<!-- <input type="range" id="rotate" min="0" max="360" value ="360" step = "30" onchange="rotate()"/> -->

		<a>Make sure to type the function in a programming format, for example, 2x+3 is <b>2*x+3</b>, and sin(2x) is <b>Math.sin(2*x)</b>.</a>
		<br>
		<select id="quality" onchange="submit()">
			<option value="0.5">Select Quality
			<option value="1">Low
			<option value="0.5">Medium
			<option value="0.25">High
			<option value="0.1">Ultra
		</select>
		<br>
		<a>This calculator is a <b>work in progress</b> and things may not work as expected! Also beware that this calculator is <b>extremely</b> memory heavy, and requires a lot of CPU.</a>

		<noscript>
			<div id="javascript-error-message" style="font-family: monospace; font-size: 13px; font-weight: normal; text-align: center; background: none repeat scroll 0% 0% rgb(255, 255, 255); color: rgb(0, 0, 0); padding: 1.5em; width: 400px; margin: 5em auto 0px;">
				<a>Your browser seems to have <a href="http://en.wikipedia.org/wiki/JavaScript">Javascript</a> turned off.</a>
				<br>
				<a>Find out how to enable it <a href="http://www.enable-javascript.com/">here</a>.</a>
			</div>
		</noscript>

		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CanvasInput.js"></script>
		<script src="js/ThreeCSG.js"></script>
		<script src="js/Detector.js"></script>
		<script>
			var camera, controls, scene, renderer;
			var theFunctionValue;
			var bound1, bound2;
			var size=28;
			var graphArray = [];
			var supportsWebGL = ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )();

			init();

			function init(){
				if(!supportsWebGL){  //No WebGL D:
					Detector.addGetWebGLMessage();
					return;
				}

				scene=new THREE.Scene();

				camera=new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
				camera.position.x=0;
				camera.position.y=50;
				camera.position.z=5;

				renderer=new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight)
				document.body.appendChild(renderer.domElement);

				controls=new THREE.TrackballControls(camera, renderer.domElement);
				controls.addEventListener('change', render);

				addAxis();
				addLights();
				animate();
				render();
			}

			function Graph(given, graphID){
				var func, group, bound1, bound2, graphID;
				this.given=given;
				this.func=func;
				this.group = new THREE.Object3D();
				this.bound1 = bound1;
				this.bound2 = bound2;
				this.graphID = graphID;
			}

			Graph.prototype.draw=function(){
				var x=-size;
				var points=[];
				var counter=x;  //I'll change this later, just using a counter variable for now
				var step=0.01;
				for(var i=-size; i<=size; i+=step){
					if(this.given!=null){
						this.func=-(eval(this.given));  //Somehow the plane is upside-down: the positive y-cordinate is negative
					}

					points[counter+size]=new THREE.Vector3(x.toFixed(2), 0, this.func);
					x+=step;
					counter++;
				}

				var geometry=new THREE.Geometry();
				geometry.verticesNeedUpdate=true;
				geometry.dynamic=true;

				var spline=new THREE.SplineCurve3(points);
				var splinePoints=spline.getPoints(points.length-1);

				for(var i=0; i<splinePoints.length; i++){
					if(Math.abs((spline.points[i]).z)<=size){
						geometry.vertices.push(spline.points[i]);
					}
				}

				var graph=new THREE.Line(geometry, new THREE.LineBasicMaterial());

				graph.name="graph";
				scene.add(graph);
				render();
			}

			Graph.prototype.getY=function(x){
				return eval(this.given);
			}

			Graph.prototype.drawShape=function(value, bound1, bound2, axisOfRotation){
				var quality = Number(value);
				this.group.name = "solid";
				var boundY1 = this.getY(bound1);
				this.bound1 = bound1;
				var boundY2 = this.getY(bound2);
				this.bound2 = bound2;
				var graph2CompareingPoint1 = graphArray[1].getY(bound1+0.5);
				var graph2CompareingPoint2 = graphArray[1].getY(bound2-0.5);
				var graph1CompareingPoint1 = graphArray[0].getY(bound1+0.5);
				var graph1CompareingPoint2 = graphArray[0].getY(bound2-0.5);
				if(bound1===bound2){
					window.alert("We're still working on creating the solid when the bounds are equal.\nSorry about that :(");
					return;
				}
				//I know this is a lot of if statements, I did it to ensure there wouldn't be any bugs. There are probably ways you can have an abridged version, but this will do for now.
				//Hmm the flipping variable idea could work very well here... I'll work on that when I have time, or you can do it. -Victor
				if(axisOfRotation){
					if(boundY2 > boundY1){
						if(axisOfRotation >= boundY2){
							if(boundY1 >= 0 && boundY2 >=0){
								console.log("1,1");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("axisOfRotation-graphArray[1].getY(i)", "axisOfRotation-graphArray[1].getY(i+1)", "axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "axisOfRotation-graphArray[1].getY(i)", "axisOfRotation-graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								}
							} else {
								console.log("1,4");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("axisOfRotation+Math.abs(graphArray[1].getY(i))", "axisOfRotation+Math.abs(graphArray[1].getY(i+1))", "axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "axisOfRotation-graphArray[1].getY(i)", "axisOfRotation-graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								}
							}
						} else if(axisOfRotation <= boundY1){
							if(boundY1 >= 0 && boundY2 >=0){
								console.log("1,2");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("Math.abs(axisOfRotation)+this.getY(i)", "Math.abs(axisOfRotation)+this.getY(i+1)", "Math.abs(axisOfRotation)+graphArray[1].getY(i)", "Math.abs(axisOfRotation)+graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("Math.abs(axisOfRotation)+graphArray[1].getY(i)", "Math.abs(axisOfRotation)+graphArray[1].getY(i+1)", "Math.abs(axisOfRotation)+this.getY(i)", "Math.abs(axisOfRotation)+this.getY(i+1)", "50", "360", axisOfRotation);
								}
							} else {  //Super hacky bugfix with the 0.01 (-x, -4, 0, 4)
								console.log("1,3"); //not working
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("Math.abs(axisOfRotation-this.getY(i))+0.01", "Math.abs(axisOfRotation-this.getY(i+1))+0.01", "Math.abs(axisOfRotation-graphArray[1].getY(i))", "Math.abs(axisOfRotation-graphArray[1].getY(i+1))", "50", "360", axisOfRotation);
								} else {
									this.addBSP("Math.abs(axisOfRotation-graphArray[1].getY(i))+0.01", "Math.abs(axisOfRotation-graphArray[1].getY(i+1))+0.01", "Math.abs(axisOfRotation-this.getY(i))", "Math.abs(axisOfRotation-this.getY(i+1))", "50", "360", axisOfRotation);
								}
							}
						} else {
							window.alert("Axis of rotation cannot be between the bounds");
						}
					} else if(boundY2 < boundY1){
						if(axisOfRotation >= boundY1){
							if(boundY1 >= 0 && boundY2 >= 0){  //Super hacky bugfix with the 0.01 (-x, -4, 0, 4)
								console.log("2,3");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("axisOfRotation-graphArray[1].getY(i)+0.01", "axisOfRotation-graphArray[1].getY(i+1)+0.01", "axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("axisOfRotation-this.getY(i)+0.01", "axisOfRotation-this.getY(i+1)+0.01", "axisOfRotation-graphArray[1].getY(i)", "axisOfRotation-graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								}
							} else {
								console.log("2,1");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("axisOfRotation+Math.abs(graphArray[1].getY(i))", "axisOfRotation+Math.abs(graphArray[1].getY(i+1))", "axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("axisOfRotation-this.getY(i)", "axisOfRotation-this.getY(i+1)", "axisOfRotation-graphArray[1].getY(i)", "axisOfRotation-graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								}
							}
						} else if(axisOfRotation <= boundY2){
							if(boundY1 >= 0 && boundY2 >=0){
								console.log("2,4");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("Math.abs(axisOfRotation)+this.getY(i)", "Math.abs(axisOfRotation)+this.getY(i+1)", "Math.abs(axisOfRotation)+graphArray[1].getY(i)", "Math.abs(axisOfRotation)+graphArray[1].getY(i+1)", "50", "360", axisOfRotation);
								} else {
									this.addBSP("Math.abs(axisOfRotation)+graphArray[1].getY(i)", "Math.abs(axisOfRotation)+graphArray[1].getY(i+1)", "Math.abs(axisOfRotation)+this.getY(i)", "Math.abs(axisOfRotation)+this.getY(i+1)", "50", "360", axisOfRotation);
								}
							} else {
								console.log("2,2");
								if(graph2CompareingPoint1>graph1CompareingPoint1 && graph2CompareingPoint2>graph1CompareingPoint2){
									this.addBSP("Math.abs(axisOfRotation-this.getY(i))+0.01", "Math.abs(axisOfRotation-this.getY(i+1))+0.01", "Math.abs(axisOfRotation-graphArray[1].getY(i))", "Math.abs(axisOfRotation-graphArray[1].getY(i+1))", "50", "360", axisOfRotation);
								} else {
									this.addBSP("Math.abs(axisOfRotation-graphArray[1].getY(i))+0.01", "Math.abs(axisOfRotation-graphArray[1].getY(i+1))+0.01", "Math.abs(axisOfRotation-this.getY(i))", "Math.abs(axisOfRotation-this.getY(i+1))", "50", "360", axisOfRotation);
								}
							}
						/*} else {  //Pretty sure this can't happen unless I'm missing something obvious?
							window.alert("Axis of rotation cannot be less than the smaller bound or greater than the larger bound");*/
						}
					} else if (boundY1===boundY2 && this.bound1 != this.bound2){
						//Not complete yet
						//This is not just for cylinders
						if(axisOfRotation > boundY1){
							this.addBSP("Math.abs(axisOfRotation-this.getY(i))", "Math.abs(axisOfRotation-this.getY(i+1))", "Math.abs(axisOfRotation)", "Math.abs(axisOfRotation)", "50", "360", axisOfRotation);
						} else if (axisOfRotation < boundY2){
							this.addBSP("Math.abs(axisOfRotation)", "Math.abs(axisOfRotation)", "Math.abs(axisOfRotation) + this.getY(i)", "Math.abs(axisOfRotation) + this.getY(i+1)", "50", "360", axisOfRotation);
						} else if (axisOfRotation == boundY2){
							this.addSolidWithoutHoles(quality,"Math.abs(this.getY(i))","Math.abs(this.getY(i+quality))", axisOfRotation);
						}
					}
				} else {
					this.addSolidWithoutHoles(quality,"Math.abs(this.getY(i))","Math.abs(this.getY(i+quality))", axisOfRotation);
				}
				scene.add(this.group);
				render();
			}

			Graph.prototype.addSolidWithoutHoles = function(quality, leftRadius, rightRadius, axisOfRotation){
				var bound1 = this.bound1;
				var bound2 = this.bound2;
				if(this.getY(bound1) > this.getY(bound2)){  //Switch the bounds around so that the for loop works
					var temp=bound2;
					bound2=bound1;
					bound1=temp;
				}

				for(var i=bound1; i<bound2; i+=quality){
					if(this.getY(i)<=size){
						var geometry=new THREE.CylinderGeometry(eval(leftRadius), eval(rightRadius), quality, 100);
						geometry.verticesNeedUpdate=true;
						geometry.dynamic=true;
						geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,-(i+quality/2), -axisOfRotation));

						var material=new THREE.MeshPhongMaterial({color: 0xffff00, shading: THREE.SmoothShading/*, transparent: true, opacity: 0.5*/});
						var plane=new THREE.Mesh(geometry, material);
						plane.material.color.setHex(0xffff00);

						plane.rotation.set(0, 0, Math.PI/2);
						this.group.add(plane);
					}
				}
			}

			Graph.prototype.addBSP = function(smallGeoR1, smallGeoR2, bigGeoR1, bigGeoR2, smallSeg, bigSeg, axisOfRotation){
				for(var i=this.bound1; i<this.bound2; i+=1){
					if(this.getY(i)<=size){
						console.log("SG1: " + eval(smallGeoR1) + " SG2: " + eval(smallGeoR2) + " BG1: " + eval(bigGeoR1) + " BG2: " + eval(bigGeoR2));
						var smallCylinderGeom=new THREE.CylinderGeometry(eval(smallGeoR1), eval(smallGeoR2), 1, smallSeg);
						smallCylinderGeom.applyMatrix(new THREE.Matrix4().makeTranslation(0, -(i+1/2), -axisOfRotation));
						var largeCylinderGeom=new THREE.CylinderGeometry(eval(bigGeoR1), eval(bigGeoR2), 1, bigSeg);
						largeCylinderGeom.applyMatrix(new THREE.Matrix4().makeTranslation(0, -(i+1/2), -axisOfRotation));
						var smallCylinderBSP=new ThreeBSP(smallCylinderGeom);
						var largeCylinderBSP=new ThreeBSP(largeCylinderGeom);
						var intersectionBSP=largeCylinderBSP.subtract(smallCylinderBSP);
						var material=new THREE.MeshPhongMaterial({color: 0xffff00/*, transparent: true, opacity: 0.5*/});
						var hollowCylinder=intersectionBSP.toMesh(material);
						hollowCylinder.rotation.set(0, 0, Math.PI/2);
						this.group.add(hollowCylinder);
					}
				}
			}

			function clearGraph(){
				for(var i=scene.children.length; i>=0; i--){
					if(scene.children[i]!=null){
						if(scene.children[i].name=="graph" || scene.children[i].name=="solid"){
							scene.remove(scene.children[i]);
						}
					}
				}
			}

			function submit(){
				clearGraph();
				//Being lazy for now, I'll change this later. Using eval()
				var box=document.getElementById("function");
				theFunctionValue=box.value.replace(/ /g,'');
				//Graph
				var func=new Graph(theFunctionValue, 0);
				graphArray[func.graphID] = func;
				if(document.getElementById("function2").value){
					var value2 = document.getElementById("function2").value;
					var func2 = new Graph(document.getElementById("function2").value, 1);
					graphArray[func2.graphID] = func2;
					func2.draw();
				} else {
					var func2 = new Graph("0", 1);
					graphArray[func2.graphID] = func2;
				}
				func.draw();

				var quality=document.getElementById("quality").value;
				var bound1=Number(document.getElementById("bound1").value);
				var bound2=Number(document.getElementById("bound2").value);
				var rotation=Number(document.getElementById("rotation").value);
				func.drawShape(quality, bound1, bound2, rotation);
			}

			function animate(){
				requestAnimationFrame(animate);
				controls.update();
			}

			function render(){
				renderer.render(scene, camera);
			}

			function addLights(){
				hemiLight=new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
				hemiLight.color.setHSL(0.6, 1, 0.6);
				hemiLight.groundColor.setHSL(0.095, 1, 0.75);
				hemiLight.position.set(0, 500, 0);
				scene.add(hemiLight);

				var light1=new THREE.PointLight(0xffff00, 1, 5000);
				light1.position.set(0, 100, 90);
				scene.add(light1);
			}

			function addAxis(){
				var geometry=new THREE.Geometry();
				geometry.verticesNeedUpdate=true;
				geometry.dynamic=true;

				var axes = new THREE.Geometry();
				axes.verticesNeedUpdate=true;
				axes.dynamic=true;

				for(var i=-size; i<=size; i+=1){
					if(i == 0){
						axes.vertices.push(new THREE.Vector3(-size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(size, -0.04, i));
						axes.vertices.push(new THREE.Vector3(i, -0.04, -size));
						axes.vertices.push(new THREE.Vector3(i, -0.04, size));
					} else {
						geometry.vertices.push(new THREE.Vector3(-size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(size, -0.04, i));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, -size));
						geometry.vertices.push(new THREE.Vector3(i, -0.04, size));
					}
				}

				var material=new THREE.LineBasicMaterial({color: "green"});
				var axismaterial=new THREE.LineBasicMaterial({color: "red"});
				var line=new THREE.Line(geometry, material, THREE.LinePieces);
				var lineaxes=new THREE.Line(axes, axismaterial, THREE.LinePieces);

				scene.add(line);
				scene.add(lineaxes);
			}
		</script>
	</body>
</html>
